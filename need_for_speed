#include<iostream>
#include<vector>
#include<ctime>
#include<cmath>
#include<cstdlib>

using namespace std;

struct segment {
    int distance_in_miles;
    int speedometer_reading;
    
    segment () : distance_in_miles (0), speedometer_reading (0) {
    }
    void get_data (int distance, int speed) {
        distance_in_miles = distance;
        speedometer_reading = speed;
    }
};

vector<int> operator * (int cons, vector<int> poly) {
    
    vector<int> polynomial;
    
    for (int i = 0; i < poly.size(); i++)
        polynomial.push_back(cons * poly[i]);
    
    return polynomial;
    
}

vector<int> operator + (vector<int> poly_r, vector<int> poly_l) {
    
    vector<int> poly;
    
    for (int i = 0; i < poly_r.size(); i++)
        poly.push_back(poly_r[i] + poly_l[i]);
    
    return poly;
}

vector<int> operator - (vector<int> poly_r, vector<int> poly_l) {
    
    vector<int> poly;
    
    poly = poly_r;
    
    for (int i = 0; i < poly_l.size(); i++)
        poly[i] = poly_r[i] - poly_l[i];
    
    return poly;
    
}

vector<int> polynomial_coefficents (int, vector<segment>);
void polynomial_reduce (vector<int> &);
long double solve (vector<int>);
long double f (long double, vector<int>);
long double f_prime (long double, vector<int>);
bool check_answer (long double, vector<segment>);

int main () {
    
    int number_of_sections, total_time;
    
    cin >> number_of_sections >> total_time;
    
    int i;
    
    vector<segment> journey;
    segment journey_i;
    int distance, speed;
    
    i = 0;
    while (i < number_of_sections) {
        cin >> distance >> speed;
        journey_i.get_data(distance, speed);
        journey.push_back(journey_i);
        i++;
    }
    
    vector<int> polynomial_l(number_of_sections + 1);
    
    polynomial_l = total_time * polynomial_coefficents (-1, journey);
    
    vector<int> polynomial_r(number_of_sections);
    
    for (i = 0; i < journey.size(); i++)
        polynomial_r = polynomial_r + journey[i].distance_in_miles * polynomial_coefficents(i, journey);
    
    vector<int> polynomial(number_of_sections + 1);
    
    polynomial = polynomial_l - polynomial_r;
    
    polynomial_reduce(polynomial);
    
    long double const_shift;
    
    do {
        
        const_shift = solve(polynomial);
        
    } while (!check_answer(const_shift, journey));
    
    cout << const_shift << endl;
    
    return 0;
}

vector<int> polynomial_coefficents (int index, vector<segment> journey) {
    
    vector<segment> section;
    vector<int> polynomial(journey.size());
    
    if (index == -1) {
        polynomial.push_back(0);
    }
    else {
        if (journey.size() == 1) {
            polynomial[0] = 1;
            return polynomial;
        }
        
        journey.erase(journey.begin() + index);
    }
    
    section = journey;
    
    polynomial[0] = section[0].speedometer_reading;
    polynomial[1] = 1;
    
    for (int i = 1; i < section.size(); i++) {
        polynomial[i + 1] = polynomial[i];
        for (int j = i; j > 0; j--)
            polynomial[j] = polynomial[j] * section[i].speedometer_reading + polynomial[j - 1];
        polynomial[0] *= section[i].speedometer_reading;
    }
    
    return polynomial;
    
}

void polynomial_reduce (vector<int> &poly) {
    
    if (poly.size() > 1) {
        if (poly[0] == 0) {
            poly.erase(poly.begin());
            polynomial_reduce (poly);
        }
    }
    
}

long double solve (vector<int> poly) {
    
    if (poly.size() == 1)
        return 0.;
    
    srand(time(0));
    
    long double c, c_r, c_l;
    long double tolerance = 0.0000000001;
    
    int p;
    
    p = rand () % 10 + 1;
    
    if (p <= 5) {
        c_l = -rand();
    }
    else {
        c_l = rand();
    }
    
    do {
        while (abs(f_prime(c_l, poly)) <= tolerance) {
            if (abs(f(c_l, poly)) <= tolerance)
                return c_l;
            
            p = rand () % 10 + 1;
            
            if (p <= 5) {
                c_l = -rand();
            }
            else {
                c_l = rand();
            }
        }
        
        c = f(c_l, poly) / f_prime(c_l, poly);
        c_r = c_l - c;
        c_l = c_r;
        
    } while (abs(c) > tolerance);
    
    return c_l;
    
}

bool check_answer (long double c, vector<segment> section) {
    
    for (int i = 0; i < section.size(); i++)
        if (c + section[i].speedometer_reading <= 0)
            return false;
    return true;
    
}

long double f (long double c, vector<int> poly) {
    
    long double result;
    
    result = 0.;
    for (int i = 0; i < poly.size(); i++)
        result += pow(c, i) * poly[i];
    
    return result;
    
}

long double f_prime (long double c, vector<int> poly) {
    
    long double result;
    
    result = 0.;
    for (int i = 1; i < poly.size(); i++)
        result += pow(c, i - 1) * poly[i] * i;
    
    return result;
    
}
